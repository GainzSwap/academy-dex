{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "contracts/common/libs/Fee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"./Math.sol\";\nimport \"./Number.sol\";\n\nlibrary FeeUtil {\n\tusing Number for uint256;\n\n\tuint256 constant MAX_PERCENT = 100_00;\n\n\tstruct Values {\n\t\tuint256 toBurnValue;\n\t\tuint256 referrerValue;\n\t\tuint256 liqProvidersValue;\n\t}\n\n\t/// One to three decimal places\n\tuint64 constant RATIO_BALANCE_FACTOR = 1_000;\n\n\tuint64 constant MIN_FEE = 10;\n\tuint64 constant FIRST_FEE = 30;\n\tuint64 constant SECOND_FEE = 3_00;\n\tuint64 constant THIRD_FEE = uint64(MAX_PERCENT);\n\n\tfunction feePercent(\n\t\tuint256 pairTotalSales,\n\t\tuint256 totalLiq,\n\t\tuint64 pairsCount\n\t) internal pure returns (uint256 percent) {\n\t\tuint64 ratio = _pairRatio(pairTotalSales, totalLiq, pairsCount);\n\n\t\t(\n\t\t\tuint64 minIn,\n\t\t\tuint64 maxIn,\n\t\t\tuint64 minOut,\n\t\t\tuint64 maxOut\n\t\t) = _getInterValues(ratio, pairsCount);\n\n\t\tpercent = MathUtil.linearInterpolation(\n\t\t\tminIn,\n\t\t\tmaxIn,\n\t\t\tratio,\n\t\t\tminOut,\n\t\t\tmaxOut\n\t\t);\n\t}\n\n\tfunction _getInterValues(\n\t\tuint256 ratio,\n\t\tuint64 pairsCount\n\t)\n\t\tprivate\n\t\tpure\n\t\treturns (uint64 minIn, uint64 maxIn, uint64 minOut, uint64 maxOut)\n\t{\n\t\tminIn = 1;\n\t\tmaxIn = RATIO_BALANCE_FACTOR;\n\t\tminOut = MIN_FEE;\n\t\tmaxOut = FIRST_FEE;\n\n\t\tuint64 MAX_RATIO_BALANCE_FACTOR = _maxRatioBalanceFactor(pairsCount);\n\n\t\tuint64 count = 0;\n\t\twhile (ratio > maxIn) {\n\t\t\tminIn = maxIn + 1;\n\t\t\tminOut = maxOut + 1;\n\n\t\t\tif (count == 0) {\n\t\t\t\tmaxIn = MAX_RATIO_BALANCE_FACTOR / 5;\n\t\t\t\tmaxOut = SECOND_FEE;\n\t\t\t} else if (count == 1) {\n\t\t\t\tmaxIn = MAX_RATIO_BALANCE_FACTOR;\n\t\t\t\tmaxOut = THIRD_FEE;\n\t\t\t} else {\n\t\t\t\trevert(\n\t\t\t\t\t\"Fee._getInterValues: max call depth for interpolation values\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tfunction _maxRatioBalanceFactor(\n\t\tuint64 pairsCount\n\t) private pure returns (uint64 max) {\n\t\tmax = pairsCount * RATIO_BALANCE_FACTOR;\n\t}\n\n\tfunction _pairRatio(\n\t\tuint256 pairTotalSales,\n\t\tuint256 totalLiq,\n\t\tuint64 pairsCount\n\t) private pure returns (uint64 ratio) {\n\t\tuint256 value = (pairTotalSales * RATIO_BALANCE_FACTOR) /\n\t\t\t_liqRatio(totalLiq, pairsCount);\n\t\tratio = value.clamp(1, _maxRatioBalanceFactor(pairsCount));\n\t}\n\n\tfunction _liqRatio(\n\t\tuint256 sales,\n\t\tuint64 pairsCount\n\t) private pure returns (uint256 gRatio) {\n\t\trequire(pairsCount > 0, \"FeeUtil: no available pairs\");\n\n\t\tgRatio = sales / pairsCount;\n\t\tif (gRatio <= 1) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Computes the total fee shares.\n\t * @param self The fee shares struct.\n\t * @return The total fee value.\n\t */\n\tfunction total(Values memory self) internal pure returns (uint256) {\n\t\treturn self.toBurnValue + self.referrerValue + self.liqProvidersValue;\n\t}\n\n\t/**\n\t * @dev Splits the fee into shares for burning, referrer, and liquidity providers.\n\t * @param fee The total fee amount.\n\t * @return A Values struct with the split values.\n\t */\n\tfunction splitFee(uint256 fee) internal pure returns (Values memory) {\n\t\tuint256 toBurnValue = (fee * 5_00) / MAX_PERCENT; // 5%\n\t\tuint256 referrerValue = (fee * 2_00) / MAX_PERCENT; // 2%\n\t\tuint256 liqProvidersValue = fee - toBurnValue - referrerValue;\n\n\t\treturn Values(toBurnValue, referrerValue, liqProvidersValue);\n\t}\n}\n"
    },
    "contracts/common/libs/Math.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nlibrary MathUtil {\n\t/// out = (minOut * (maxIn - currentIn) + maxOut * (currentIn - minIn)) / (maxIn - minIn)\n\t/// https://en.wikipedia.org/wiki/LinearInterpolation\n\tfunction linearInterpolation(\n\t\tuint256 minIn,\n\t\tuint256 maxIn,\n\t\tuint256 currentIn,\n\t\tuint256 minOut,\n\t\tuint256 maxOut\n\t) internal pure returns (uint256) {\n\t\tif (currentIn < minIn || currentIn > maxIn) {\n\t\t\trevert(\"Math.linearInterpolation: Invalid values\");\n\t\t}\n\n\t\tuint256 minOutWeighted = minOut * (maxIn - currentIn);\n\t\tuint256 maxOutWeighted = maxOut * (currentIn - minIn);\n\t\tuint256 inDiff = maxIn - minIn;\n\n\t\treturn (minOutWeighted + maxOutWeighted) / inDiff;\n\t}\n}\n"
    },
    "contracts/common/libs/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\ncontract MintableERC20 is ERC20, Ownable, ERC20Burnable {\n\tconstructor(\n\t\tstring memory name_,\n\t\tstring memory symbol_\n\t) ERC20(name_, symbol_) {}\n\n\tfunction mint(address to, uint256 amt) external onlyOwner {\n\t\t_mint(to, amt);\n\t}\n}\n"
    },
    "contracts/common/libs/Number.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nlibrary Number {\n\t/// Restrict a value to a certain interval (Inspired by the `clamp` method in Rust number types).\n\t///\n\t/// Returns `max` if `self` is greater than `max`, and `min` if `self` is\n\t/// less than `min`. Otherwise this returns `self`.\n\t///\n\t/// # Panics\n\t///\n\t/// Panics if `min > max`.\n\t///\n\tfunction clamp(\n\t\tuint256 self,\n\t\tuint64 min,\n\t\tuint64 max\n\t) internal pure returns (uint64 clamped) {\n\t\tassert(min <= max);\n\t\tif (self < min) {\n\t\t\tclamped = min;\n\t\t} else if (self > max) {\n\t\t\tclamped = max;\n\t\t} else {\n\t\t\tassembly {\n\t\t\t\tclamped := self\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/common/libs/Slippage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nlibrary Slippage {\n\tuint256 constant MAX_PERCENTAGE = 100_00;\n\n\tfunction _checkSlippage(uint256 slippage) private pure returns (uint256) {\n\t\tif (slippage < 1 || slippage > MAX_PERCENTAGE) {\n\t\t\trevert(\"Invalid slippage value\");\n\t\t}\n\n\t\treturn MAX_PERCENTAGE - slippage;\n\t}\n\n\tfunction compute(\n\t\tuint256 amount,\n\t\tuint256 slippage\n\t) internal pure returns (uint256) {\n\t\treturn (amount * _checkSlippage(slippage)) / MAX_PERCENTAGE;\n\t}\n}\n"
    },
    "contracts/common/libs/TokenPayments.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nimport \"./Types.sol\";\n\nlibrary TokenPayments {\n\tfunction receiveERC20(ERC20TokenPayment calldata payment) internal {\n\t\tpayment.token.transferFrom(msg.sender, address(this), payment.amount);\n\t}\n\n\tfunction receiveERC20(\n\t\tERC20TokenPayment calldata payment,\n\t\taddress from\n\t) internal {\n\t\tpayment.token.transferFrom(from, address(this), payment.amount);\n\t}\n}\n"
    },
    "contracts/common/libs/Types.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nstruct ERC20TokenPayment {\n\tIERC20 token;\n\tuint256 amount;\n}\n"
    },
    "contracts/pair/Amm.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nlibrary Amm {\n\tfunction calculateKConstant(\n\t\tuint256 firstTokenAmt,\n\t\tuint256 secondTokenAmt\n\t) internal pure returns (uint256) {\n\t\treturn firstTokenAmt * secondTokenAmt;\n\t}\n\n\tfunction quote(\n\t\tuint256 firstTokenAmount,\n\t\tuint256 firstTokenReserve,\n\t\tuint256 secondTokenReserve\n\t) internal pure returns (uint256) {\n\t\treturn (firstTokenAmount * secondTokenReserve) / firstTokenReserve;\n\t}\n\n\tfunction getAmountOut(\n\t\tuint256 amountIn,\n\t\tuint256 reserveIn,\n\t\tuint256 reserveOut\n\t) internal pure returns (uint256) {\n\t\tuint256 numerator = amountIn * reserveOut;\n\t\tuint256 denominator = reserveIn + amountIn;\n\n\t\treturn numerator / denominator;\n\t}\n}\n"
    },
    "contracts/pair/BasePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"./Pair.sol\";\nimport \"../common/libs/MintableERC20.sol\";\n\n/**\n * @title BasePair\n * @dev This contract represents a base pair in the DEX, implementing mintable tokens and fee burning mechanisms.\n */\ncontract BasePair is Pair, IBasePair {\n\tconstructor()\n\t\tPair(\n\t\t\taddress(new MintableERC20(\"AcademyDEX-BaseToken\", \"BASE\")),\n\t\t\taddress(this)\n\t\t)\n\t{}\n\n\t/**\n\t * @notice Mints the initial supply of the base trade token to the specified recipient.\n\t * @dev This function can only be called by the owner of the contract.\n\t *      The minting only occurs if the total supply of the trade token is zero.\n\t * @param amount The amount of tokens to mint as the initial supply.\n\t * @param recipient The address to receive the minted tokens.\n\t */\n\tfunction mintInitialSupply(\n\t\tuint256 amount,\n\t\taddress recipient\n\t) external onlyOwner {\n\t\t// Check if the total supply of the trade token is zero\n\t\tif (tradeToken.totalSupply() == 0) {\n\t\t\t// Mint the specified amount of the trade token to the recipient\n\t\t\tMintableERC20(address(tradeToken)).mint(recipient, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Mints rewards to the calling pair address.\n\t * @param amount Amount of rewards to mint.\n\t */\n\tfunction mintRewards(uint256 amount) external isKnownPair {\n\t\taddress pairAddress = msg.sender;\n\t\tPair pair = Pair(pairAddress);\n\n\t\tuint256 mintAmount = Amm.quote(amount, pair.reserve(), reserve());\n\n\t\tMintableERC20 token = MintableERC20(address(tradeToken));\n\t\ttoken.mint(address(this), mintAmount);\n\t\t// TODO send some mintAmount to others in ecosystem\n\t\ttoken.approve(pairAddress, mintAmount);\n\n\t\tpair.receiveReward(\n\t\t\tERC20TokenPayment({ amount: mintAmount, token: token })\n\t\t);\n\t}\n}\n"
    },
    "contracts/pair/contexts/AddLiquidity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"../../common/libs/Types.sol\";\n\nstruct AddLiquidityContext {\n\tuint256 liq;\n\tuint256 deposit;\n}\n"
    },
    "contracts/pair/Errors.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nerror ErrorInvalidArgs();\nerror ErrorBadPaymentTokens();\nerror ErrorNotActive();\n\n/// Initial liquidity was not added\nerror ErrorInitialLiquidityNotAdded();\n\n/// The current safe price index of `currentIndex` is greater than the maximum number of observations `maxIndex`\n/// @param currentIndex the current index\n/// @param maxIndex the maximum possible index\nerror ErrorSafePriceCurrentIndex(uint currentIndex, uint maxIndex);\n\n/// index out of range\nerror IndexOutOfRangeErrMsg();\n\n/// K invariant failed\nerror ErrorKInvariantFailed();\n\n/// Insufficient liquidity minted\nerror ErrorInsufficientLiquidity();\n\n/// First tokens needs to be greater than minimum liquidity\nerror ErrorFirstLiquidity();\n\n/// Optimal amount greater than desired amount\nerror ErrorOptimalGreaterThanPaid();\n\n/// Insufficient first token computed amount\nerror ErrorInsufficientFirstToken();\n\n/// Insufficient second token computed amount\nerror ErrorInsufficientSecondToken();\n\n/// Permission denied\nerror ErrorPermissionDenied();\n\n/// Not enough LP token supply\nerror ErrorNotEnoughLp();\n/// Insufficient liquidity burned\nerror ErrorInsufficientLiquidityBurned();\n/// Slippage amount does not match\nerror ErrorSlippageOnRemove();\n/// Not enough reserve\nerror ErrorNotEnoughReserve();\n///LP token not issued\nerror ErrorLpTokenNotIssued();\n"
    },
    "contracts/pair/Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\ninterface IPair {\n\tfunction reserve() external view returns (uint256);\n\n\tfunction completeSell(address to, uint256 amount) external;\n}\n\ninterface IBasePair is IPair {\n\tfunction mintRewards(uint256 amount) external;\n}\n"
    },
    "contracts/pair/Knowable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract KnowablePair is Ownable {\n\tmodifier isKnownPair() {\n\t\trequire(owner() == Ownable(msg.sender).owner(), \"not allowed\");\n\t\t_;\n\t}\n}\n"
    },
    "contracts/pair/Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../common/libs/Fee.sol\";\nimport \"../common/libs/Slippage.sol\";\nimport \"../common/libs/TokenPayments.sol\";\n\nimport \"./contexts/AddLiquidity.sol\";\n\nimport \"./Amm.sol\";\nimport \"./Errors.sol\";\nimport \"./SafePrice.sol\";\nimport \"./Interface.sol\";\nimport \"./Knowable.sol\";\n\n/**\n * @title Pair\n * @dev This contract manages a trading pair in the DEX, handling liquidity, trading, and fee mechanisms.\n */\ncontract Pair is IPair, Ownable, KnowablePair {\n\tusing SafePriceUtil for SafePriceData;\n\tusing FeeUtil for FeeUtil.Values;\n\n\tERC20 public immutable tradeToken;\n\tuint256 public deposits;\n\tuint256 public sales;\n\n\tuint256 public rewards;\n\tuint256 public lpSupply;\n\tIBasePair immutable basePair;\n\n\tmapping(address => SafePriceData) safePrices;\n\n\tuint256 constant MIN_MINT_DEPOSIT = 4_000;\n\n\tevent LiquidityAdded(\n\t\taddress indexed from,\n\t\tuint256 amount,\n\t\tuint256 liqAdded\n\t);\n\tevent SellExecuted(\n\t\taddress indexed from,\n\t\taddress indexed to,\n\t\tuint256 amountIn,\n\t\tuint256 amountOut,\n\t\tuint256 fee\n\t);\n\tevent RewardReceived(address indexed from, uint256 amount);\n\tevent BalanceUpdated(address indexed user, uint256 balance);\n\n\t/**\n\t * @dev Constructor for initializing the Pair contract.\n\t * @param tradeToken_ Address of the trade token.\n\t * @param basePairAddr Address of the base pair.\n\t */\n\tconstructor(address tradeToken_, address basePairAddr) {\n\t\trequire(tradeToken_ != address(0), \"Pair: Invalid trade token address\");\n\t\trequire(basePairAddr != address(0), \"Pair: Invalid base pair address\");\n\n\t\ttradeToken = ERC20(tradeToken_);\n\t\trequire(\n\t\t\tbytes(tradeToken.symbol()).length > 0,\n\t\t\t\"Pair: Invalid trade token\"\n\t\t);\n\n\t\tbasePair = IBasePair(basePairAddr);\n\t\t// TODO Write checks to ensure that base pair trade token is valid ERC20 token\n\t\t// require(\n\t\t// \tbytes(ERC20(Pair(basePairAddr).tradeToken()).symbol()).length > 0,\n\t\t// \t\"Pair: Invalid base pair contract\"\n\t\t// );\n\t}\n\n\tmodifier onlyBasePair() {\n\t\trequire(msg.sender == address(basePair), \"not allowed\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Internal function to check and receive a payment.\n\t * @param payment Payment details.\n\t * @param from Address from which payment is received.\n\t */\n\tfunction _checkAndReceivePayment(\n\t\tERC20TokenPayment calldata payment,\n\t\taddress from\n\t) internal {\n\t\t_checkAndReceivePayment(payment, from, MIN_MINT_DEPOSIT);\n\t}\n\n\tfunction _checkAndReceivePayment(\n\t\tERC20TokenPayment calldata payment,\n\t\taddress from,\n\t\tuint256 min\n\t) internal {\n\t\tif (payment.token != tradeToken || payment.amount < min) {\n\t\t\trevert(\"Pair: Bad received payment\");\n\t\t}\n\n\t\tTokenPayments.receiveERC20(payment, from);\n\t}\n\n\tfunction _getReserves()\n\t\tinternal\n\t\tview\n\t\treturns (uint256 paymentTokenReserve, uint256 baseTokenReserve)\n\t{\n\t\treturn (reserve(), basePair.reserve());\n\t}\n\n\tfunction _getLiqAdded(\n\t\tERC20TokenPayment calldata payment\n\t) internal view returns (uint256) {\n\t\t(\n\t\t\tuint256 paymentTokenReserve,\n\t\t\tuint256 baseTokenReserve\n\t\t) = _getReserves();\n\n\t\t// In case of initial liquidity\n\t\tpaymentTokenReserve = paymentTokenReserve <= 0\n\t\t\t? payment.amount\n\t\t\t: paymentTokenReserve;\n\n\t\treturn Amm.quote(payment.amount, paymentTokenReserve, baseTokenReserve);\n\t}\n\n\tfunction _takeFromReserve(uint256 amount) internal returns (uint256 taken) {\n\t\tif (sales >= amount) {\n\t\t\tsales -= amount;\n\t\t\treturn amount;\n\t\t}\n\n\t\tif ((deposits + sales) >= amount) {\n\t\t\ttaken = amount;\n\t\t\tdeposits -= taken - sales;\n\t\t\tsales = 0;\n\t\t} else {\n\t\t\trevert(\"Amount to be taken is too large\");\n\t\t}\n\t}\n\n\tfunction _completeSell(\n\t\tERC20TokenPayment memory inPayment,\n\t\taddress from,\n\t\tIPair outPair,\n\t\tuint256 outAmount\n\t) internal virtual {\n\t\tsales += inPayment.amount;\n\t\toutPair.completeSell(from, outAmount);\n\t\temit BalanceUpdated(from, tradeToken.balanceOf(from));\n\t\temit BalanceUpdated(address(this), tradeToken.balanceOf(address(this)));\n\t}\n\n\t/**\n\t * @notice Takes fee and update balances of beneficiaries\n\t * @dev This must be called on the out pair side\n\t * @param referrer the user address to receive part of fee\n\t * @param amount amount to compute and deduct fee from\n\t * @param totalFeePercent the fee percentage\n\t */\n\tfunction takeFees(\n\t\taddress referrer,\n\t\tuint256 amount,\n\t\tuint256 totalFeePercent\n\t) external isKnownPair returns (uint256 amountOut) {\n\t\tuint256 fee = (totalFeePercent * amount) / FeeUtil.MAX_PERCENT;\n\n\t\tamountOut = amount - fee;\n\n\t\tFeeUtil.Values memory values = FeeUtil.splitFee(fee);\n\n\t\t// Give liqProviders value\n\t\tdeposits += _takeFromReserve(values.liqProvidersValue);\n\n\t\tuint256 toBurn = values.toBurnValue;\n\t\tif (referrer != address(0) && values.referrerValue > 0) {\n\t\t\ttradeToken.transfer(\n\t\t\t\treferrer,\n\t\t\t\t_takeFromReserve(values.referrerValue)\n\t\t\t);\n\t\t} else {\n\t\t\ttoBurn += values.referrerValue;\n\t\t}\n\n\t\t// Increasing sales genrally implies the `toBurn`\n\t\t// is available for ecosystem wide usage\n\t\tsales += _takeFromReserve(toBurn);\n\t}\n\n\tfunction _executeSell(\n\t\tERC20TokenPayment memory inPayment,\n\t\taddress from,\n\t\taddress referrer,\n\t\tPair outPair,\n\t\tuint256 slippage,\n\t\tuint256 totalFeePercent\n\t) private {\n\t\tuint256 inTokenReserve = reserve();\n\t\tuint256 outTokenReserve = outPair.reserve();\n\n\t\tuint256 amountOutMin = Amm.quote(\n\t\t\tSlippage.compute(inPayment.amount, slippage),\n\t\t\tinTokenReserve,\n\t\t\toutTokenReserve\n\t\t);\n\t\trequire(outTokenReserve > amountOutMin, \"Pair: not enough reserve\");\n\n\t\tsafePrices[address(outPair)].updateSafePrice(\n\t\t\tinTokenReserve,\n\t\t\toutTokenReserve\n\t\t);\n\n\t\tuint256 initialK = Amm.calculateKConstant(\n\t\t\tinTokenReserve,\n\t\t\toutTokenReserve\n\t\t);\n\n\t\tuint256 amountOutOptimal = Amm.getAmountOut(\n\t\t\tinPayment.amount,\n\t\t\tinTokenReserve,\n\t\t\toutTokenReserve\n\t\t);\n\n\t\tamountOutOptimal = outPair.takeFees(\n\t\t\treferrer,\n\t\t\tamountOutOptimal,\n\t\t\ttotalFeePercent\n\t\t);\n\n\t\trequire(amountOutOptimal >= amountOutMin, \"Slippage Exceeded\");\n\t\trequire(amountOutOptimal != 0, \"Pair: Zero out amount\");\n\n\t\t_completeSell(inPayment, from, outPair, amountOutOptimal);\n\n\t\tuint256 newK = Amm.calculateKConstant(reserve(), outPair.reserve());\n\t\trequire(initialK <= newK, \"ERROR_K_INVARIANT_FAILED\");\n\n\t\temit SellExecuted(\n\t\t\tfrom,\n\t\t\taddress(outPair),\n\t\t\tinPayment.amount,\n\t\t\tamountOutOptimal,\n\t\t\ttotalFeePercent\n\t\t);\n\t}\n\n\tfunction _addBaseLiq(ERC20TokenPayment calldata wholePayment) internal {\n\t\tuint256 value = wholePayment.amount;\n\t\t_insertLiqValues(AddLiquidityContext({ deposit: value, liq: value }));\n\t}\n\n\tfunction _insertLiqValues(AddLiquidityContext memory context) internal {\n\t\tdeposits += context.deposit;\n\t\tlpSupply += context.liq;\n\t}\n\n\tfunction _addPairLiq(ERC20TokenPayment calldata wholePayment) internal {\n\t\tuint256 liqAdded = _getLiqAdded(wholePayment);\n\n\t\t(\n\t\t\tuint256 paymentTokenReserve,\n\t\t\tuint256 baseTokenReserve\n\t\t) = _getReserves();\n\n\t\tSafePriceData storage safePrice = safePrices[address(basePair)];\n\t\tsafePrice.updateSafePrice(paymentTokenReserve, baseTokenReserve);\n\n\t\tuint256 initialK = Amm.calculateKConstant(\n\t\t\tpaymentTokenReserve,\n\t\t\tbaseTokenReserve\n\t\t);\n\n\t\t_insertLiqValues(\n\t\t\tAddLiquidityContext({ deposit: wholePayment.amount, liq: liqAdded })\n\t\t);\n\n\t\t// Check K values\n\t\t(\n\t\t\tuint256 newPaymentTokenReserve,\n\t\t\tuint256 newBaseTokenReserve\n\t\t) = _getReserves();\n\t\tuint256 newK = Amm.calculateKConstant(\n\t\t\tnewPaymentTokenReserve,\n\t\t\tnewBaseTokenReserve\n\t\t);\n\t\tif (initialK > newK) {\n\t\t\trevert ErrorKInvariantFailed();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Adds liquidity to the pair.\n\t * @param wholePayment Details of the payment for adding liquidity.\n\t * @param from Address from which liquidity is added.\n\t * @return liqAdded Amount of liquidity added.\n\t */\n\tfunction addLiquidity(\n\t\tERC20TokenPayment calldata wholePayment,\n\t\taddress from\n\t) external onlyOwner returns (uint256 liqAdded) {\n\t\t_checkAndReceivePayment(wholePayment, from);\n\n\t\tbool isBasePair = address(this) == address(basePair);\n\n\t\tuint256 initalLp = lpSupply;\n\t\tif (isBasePair) {\n\t\t\t_addBaseLiq(wholePayment);\n\t\t} else {\n\t\t\t_addPairLiq(wholePayment);\n\t\t}\n\n\t\trequire(lpSupply > initalLp, \"Pair: invalid liquidity addition\");\n\t\tliqAdded = lpSupply - initalLp;\n\n\t\temit LiquidityAdded(from, wholePayment.amount, liqAdded);\n\t\temit BalanceUpdated(from, tradeToken.balanceOf(from));\n\t\temit BalanceUpdated(address(this), tradeToken.balanceOf(address(this)));\n\t}\n\n\t/**\n\t * @notice Executes a sell order.\n\t * @param caller Address of the caller.\n\t * @param referrerOfCaller Address of the referrer of the caller.\n\t * @param inPayment Details of the payment for the sell order.\n\t * @param outPair Address of the pair to sell to.\n\t * @param slippage Maximum slippage allowed.\n\t * @param totalFeePercent Total fee percentage.\n\t */\n\tfunction sell(\n\t\taddress caller,\n\t\taddress referrerOfCaller,\n\t\tERC20TokenPayment calldata inPayment,\n\t\tPair outPair,\n\t\tuint256 slippage,\n\t\tuint256 totalFeePercent\n\t) external onlyOwner {\n\t\t_checkAndReceivePayment(inPayment, caller, 0);\n\t\t_executeSell(\n\t\t\tinPayment,\n\t\t\tcaller,\n\t\t\treferrerOfCaller,\n\t\t\toutPair,\n\t\t\tslippage,\n\t\t\ttotalFeePercent\n\t\t);\n\t}\n\n\t/**\n\t * @notice Completes a sell order on the outPair side.\n\t * @param to Address to which the amount is transferred.\n\t * @param amount Amount to be transferred.\n\t */\n\tfunction completeSell(address to, uint256 amount) external isKnownPair {\n\t\ttradeToken.transfer(to, _takeFromReserve(amount));\n\t\tbasePair.mintRewards(amount);\n\t\temit BalanceUpdated(to, tradeToken.balanceOf(to));\n\t\temit BalanceUpdated(address(this), tradeToken.balanceOf(address(this)));\n\t}\n\n\t/**\n\t * @notice Returns the total amount of tradeToken that can be bought from this Pair.\n\t * @return The reserve amount.\n\t */\n\tfunction reserve() public view returns (uint256) {\n\t\treturn deposits + sales;\n\t}\n\n\tfunction receiveReward(\n\t\tERC20TokenPayment calldata payment\n\t) external onlyBasePair {\n\t\t// TODO check that payment is base pair's token\n\t\trequire(\n\t\t\tpayment.token == Pair(address(basePair)).tradeToken(),\n\t\t\t\"Pair: invalid reward token\"\n\t\t);\n\t\tTokenPayments.receiveERC20(payment);\n\t\trewards += payment.amount;\n\t\temit RewardReceived(msg.sender, payment.amount);\n\t\temit BalanceUpdated(address(this), tradeToken.balanceOf(address(this)));\n\t}\n}\n"
    },
    "contracts/pair/SafePrice.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"./Errors.sol\";\n\n// TODO use when we can do operator overloading; see https://docs.soliditylang.org/en/v0.8.23/contracts.html#using-for\n// type Round is uint256;\n\nuint constant MAX_OBSERVATIONS = 65_536; // 2^{16} records, to optimise binary search\n\nstruct PriceObservation {\n\tuint256 firstTokenReserveAccumulated;\n\tuint256 secondTokenReserveAccumulated;\n\tuint256 weightAccumulated;\n\t// Round recordingRound;\n\tuint256 recordingRound;\n}\n\nstruct IndexValue {\n\tuint keyIndex;\n\tPriceObservation value;\n}\n\nstruct priceObsvec {\n\tmapping(uint => IndexValue) data;\n\tuint[] keys;\n\tuint length;\n}\n\nlibrary PriceObsVec {\n\tfunction isEmpty(\n\t\tpriceObsvec storage self\n\t) internal view returns (bool empty) {\n\t\tempty = self.length == 0;\n\t}\n\n\tfunction get(\n\t\tpriceObsvec storage self,\n\t\tuint index\n\t) internal view returns (PriceObservation memory) {\n\t\tif (index > self.length) {\n\t\t\trevert IndexOutOfRangeErrMsg();\n\t\t}\n\n\t\treturn self.data[index].value;\n\t}\n\n\tfunction set(\n\t\tpriceObsvec storage self,\n\t\tuint index,\n\t\tPriceObservation memory value\n\t) internal {\n\t\tif (index > self.length) {\n\t\t\trevert IndexOutOfRangeErrMsg();\n\t\t}\n\n\t\tself.data[index].value = value;\n\t\tself.data[index].keyIndex = index;\n\t}\n\n\t/// Add one item at the end of the list.\n\t/// Returns the index of the newly inserted item, which is also equal to the new number of elements.\n\tfunction push(\n\t\tpriceObsvec storage self,\n\t\tPriceObservation memory value\n\t) internal returns (uint) {\n\t\tself.length += 1;\n\n\t\tself.data[self.length].value = value;\n\t\tself.data[self.length].keyIndex = self.length;\n\n\t\treturn self.length;\n\t}\n\n\tfunction len(priceObsvec storage self) internal view returns (uint) {\n\t\treturn self.length;\n\t}\n}\n\nstruct SafePriceData {\n\tuint safePriceCurrentIndex;\n\tpriceObsvec priceObservations;\n}\n\nlibrary SafePriceUtil {\n\tusing PriceObsVec for priceObsvec;\n\n\tfunction updateSafePrice(\n\t\tSafePriceData storage self,\n\t\tuint256 firstTokenReserve,\n\t\tuint256 secondTokenReserve\n\t) internal {\n\t\tif (firstTokenReserve == 0 || secondTokenReserve == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tuint currentRound = block.number;\n\n\t\tif (self.safePriceCurrentIndex > MAX_OBSERVATIONS) {\n\t\t\trevert ErrorSafePriceCurrentIndex(\n\t\t\t\tself.safePriceCurrentIndex,\n\t\t\t\tMAX_OBSERVATIONS\n\t\t\t);\n\t\t}\n\n\t\tPriceObservation memory lastPriceObservation;\n\t\tuint newIndex = 1;\n\t\tif (!self.priceObservations.isEmpty()) {\n\t\t\tlastPriceObservation = self.priceObservations.get(\n\t\t\t\tself.safePriceCurrentIndex\n\t\t\t);\n\t\t\tnewIndex = (self.safePriceCurrentIndex % MAX_OBSERVATIONS) + 1;\n\t\t}\n\n\t\tif (lastPriceObservation.recordingRound == currentRound) {\n\t\t\treturn;\n\t\t}\n\n\t\tPriceObservation memory newPriceObservation = computeNewObservation(\n\t\t\tcurrentRound,\n\t\t\tfirstTokenReserve,\n\t\t\tsecondTokenReserve,\n\t\t\tlastPriceObservation\n\t\t);\n\n\t\tif (self.priceObservations.len() == MAX_OBSERVATIONS) {\n\t\t\tself.priceObservations.set(newIndex, newPriceObservation);\n\t\t} else {\n\t\t\tself.priceObservations.push(newPriceObservation);\n\t\t}\n\n\t\tself.safePriceCurrentIndex = newIndex;\n\t}\n\n\tfunction computeNewObservation(\n\t\tuint newRound,\n\t\tuint256 newFirstReserve,\n\t\tuint256 newSecondReserve,\n\t\tPriceObservation memory currentPriceObservation\n\t) internal pure returns (PriceObservation memory newPriceObservation) {\n\t\tuint256 newWeight = currentPriceObservation.recordingRound == 0\n\t\t\t? 1\n\t\t\t: newRound - currentPriceObservation.recordingRound;\n\n\t\tnewPriceObservation = currentPriceObservation;\n\t\tnewPriceObservation.firstTokenReserveAccumulated +=\n\t\t\tnewWeight *\n\t\t\tnewFirstReserve;\n\t\tnewPriceObservation.secondTokenReserveAccumulated +=\n\t\t\tnewWeight *\n\t\t\tnewSecondReserve;\n\t\tnewPriceObservation.weightAccumulated += newWeight;\n\t\tnewPriceObservation.recordingRound = newRound;\n\t}\n}\n"
    },
    "contracts/router/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../common/libs/Fee.sol\";\n\nimport \"../pair/Pair.sol\";\nimport \"../pair/BasePair.sol\";\n\nimport \"../test-case/TestingBasePair.sol\";\nimport \"./User.sol\";\n\nlibrary PairFactory {\n\tfunction newPair(\n\t\taddress tradeToken,\n\t\taddress basePairAddr\n\t) external returns (Pair) {\n\t\treturn new Pair(tradeToken, basePairAddr);\n\t}\n\n\tfunction newBasePair() external returns (BasePair) {\n\t\treturn new BasePair();\n\t}\n}\n\nlibrary TestingPairFactory {\n\tfunction newPair(\n\t\taddress tradeToken,\n\t\taddress basePairAddr\n\t) external returns (Pair) {\n\t\treturn new Pair(tradeToken, basePairAddr);\n\t}\n\n\tfunction newBasePair() external returns (BasePair) {\n\t\treturn new TestingBasePair();\n\t}\n}\n\ncontract Router is Ownable, UserModule {\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\tusing Address for address;\n\n\tstruct PairData {\n\t\tuint256 rewardsAgainst;\n\t\tuint256 rewardsFor;\n\t\tuint256 totalLiq;\n\t}\n\n\tEnumerableSet.AddressSet private pairs;\n\tEnumerableSet.AddressSet private tradeTokens;\n\n\tmapping(address => address) public tokensPairAddress;\n\tmapping(address => PairData) public pairData;\n\n\tuint256 totalLiq;\n\tuint256 totalRewards;\n\n\t/**\n\t * @notice Calls the BasePair contract to mint the initial supply of the base trade token.\n\t * @dev This function can only be called by the owner of the contract.\n\t *      It passes the owner of the Router contract as the recipient of the minted tokens.\n\t *      The base trade token is assumed to be the first token in the `pairs` set.\n\t * @param amount The amount of tokens to mint as the initial supply.\n\t */\n\tfunction mintInitialSupply(uint256 amount) external onlyOwner {\n\t\t// Get the address of the base pair, assumed to be the first token in the pairs set\n\t\taddress basePairAddress = basePairAddr();\n\n\t\t// Instantiate the base pair contract\n\t\tBasePair basePair = BasePair(basePairAddress);\n\n\t\t// Call the mintInitialSupply function of the base pair contract,\n\t\t// passing the owner of the Router contract as the recipient\n\t\tbasePair.mintInitialSupply(amount, owner());\n\t}\n\n\t/**\n\t * @notice Creates a new pair.\n\t * @dev The first pair becomes the base pair -- For now, called by only owner..when DAO is implemented, DAO can call this\n\t * @param tradeToken Address of the trade token for the pair.\n\t * @return pair Address of the newly created pair.\n\t */\n\tfunction createPair(\n\t\taddress tradeToken\n\t) external onlyOwner returns (Pair pair) {\n\t\trequire(\n\t\t\ttokensPairAddress[tradeToken] == address(0),\n\t\t\t\"Token already added\"\n\t\t);\n\n\t\tif (pairsCount() == 0) {\n\t\t\tpair = PairFactory.newBasePair();\n\t\t\ttradeToken = address(pair.tradeToken());\n\t\t} else {\n\t\t\tpair = PairFactory.newPair(tradeToken, basePairAddr());\n\t\t}\n\n\t\tpairs.add(address(pair));\n\t\ttradeTokens.add(tradeToken);\n\t\ttokensPairAddress[tradeToken] = address(pair);\n\t}\n\n\t/**\n\t * @notice Adds liquidity to a pair.\n\t * @param wholePayment Payment details for adding liquidity.\n\t */\n\tfunction addLiquidity(ERC20TokenPayment calldata wholePayment) external {\n\t\taddress tokenAddress = address(wholePayment.token);\n\t\taddress pairAddress = tokensPairAddress[tokenAddress];\n\t\trequire(pairAddress != address(0), \"Router: Invalid pair address\");\n\n\t\tuint256 liqAdded = Pair(pairAddress).addLiquidity(\n\t\t\twholePayment,\n\t\t\tmsg.sender\n\t\t);\n\n\t\t// Upadte liquidity data to be used for other computations like fee\n\t\ttotalLiq += liqAdded;\n\t\tpairData[tokenAddress].totalLiq += liqAdded;\n\t}\n\n\t/**\n\t * @dev Becareful with parameter ordering for `ERC20TokenPayment`\n\t */\n\tfunction registerAndSwap(\n\t\tuint256 referrerId,\n\t\tERC20TokenPayment calldata inPayment,\n\t\taddress outPairAddr,\n\t\tuint256 slippage\n\t) public {\n\t\t_createOrGetUserId(msg.sender, referrerId);\n\t\tswap(inPayment, outPairAddr, slippage);\n\n\t\t// TODO learn how to do this properly i.e delegating calls with complex in put parameters\n\t\t// (bool success, ) = address(this).delegatecall(\n\t\t// \tabi.encodeWithSignature(\n\t\t// \t\t\"swap(address,uint256,address,uint256)\",\n\t\t// \t\taddress(inPayment.token),\n\t\t// \t\tinPayment.amount,\n\t\t// \t\toutPairAddr,\n\t\t// \t\tslippage\n\t\t// \t)\n\t\t// );\n\t\t// require(success, \"Router: Delegate call not succeded\");\n\t}\n\n\t/**\n\t * @notice Executes a trade between two pairs.\n\t * @param outPairAddr Address of the output pair.\n\t * @param inPayment Payment details for the trade.\n\t * @param slippage Maximum slippage allowed.\n\t */\n\tfunction swap(\n\t\tERC20TokenPayment calldata inPayment,\n\t\taddress outPairAddr,\n\t\tuint256 slippage\n\t) public {\n\t\taddress inPairAddr = tokensPairAddress[address(inPayment.token)];\n\n\t\trequire(pairs.contains(inPairAddr), \"Router: Input pair not found\");\n\t\trequire(pairs.contains(outPairAddr), \"Router: Output pair not found\");\n\n\t\tPair outPair = Pair(outPairAddr);\n\t\tuint256 initialOutPairRewards = outPair.rewards();\n\n\t\t(, address referrer) = getReferrer(msg.sender);\n\t\tPair(inPairAddr).sell(\n\t\t\tmsg.sender,\n\t\t\treferrer,\n\t\t\tinPayment,\n\t\t\toutPair,\n\t\t\tslippage,\n\t\t\tcomputeFeePercent(inPairAddr, inPayment.amount)\n\t\t);\n\n\t\tuint256 finalOutPairRewards = outPair.rewards();\n\n\t\tuint256 rewardsChange = finalOutPairRewards - initialOutPairRewards;\n\t\trequire(rewardsChange > 0, \"Router: no rewards gianed for out pair\");\n\n\t\tpairData[inPairAddr].rewardsAgainst += rewardsChange;\n\t\tpairData[outPairAddr].rewardsFor += rewardsChange;\n\t\ttotalRewards += rewardsChange;\n\t}\n\n\t/**\n\t * @notice Computes the feePercent based on the pair's sales against the liquidity provided in other pairs.\n\t * @dev The more a pair is sold, the higher the feePercent. This is computed based on the pair's sales relative to the provided liquidity in other pairs.\n\t * @param pairAddress The address of the pair for which the feePercent is being computed.\n\t * @param inAmount The input amount for which the feePercent is being computed.\n\t * @return feePercent The computed feePercent based on the input amount and the pair's sales.\n\t */\n\tfunction computeFeePercent(\n\t\taddress pairAddress,\n\t\tuint256 inAmount\n\t) public view returns (uint256 feePercent) {\n\t\tuint256 projectedRewardsChange = Amm.quote(\n\t\t\tinAmount,\n\t\t\tPair(pairAddress).reserve(),\n\t\t\tPair(basePairAddr()).reserve()\n\t\t);\n\n\t\tuint256 pairSales = pairData[pairAddress].rewardsAgainst +\n\t\t\tprojectedRewardsChange;\n\t\tuint256 pairBuys = pairData[pairAddress].rewardsFor;\n\n\t\tuint256 salesDiff = pairSales > pairBuys ? pairSales - pairBuys : 0;\n\n\t\tuint256 otherLiq = totalLiq - pairData[pairAddress].totalLiq;\n\t\tfeePercent = FeeUtil.feePercent(salesDiff, otherLiq, pairsCount());\n\t}\n\n\t/**\n\t * @notice Returns the list of all pairs.\n\t * @return Array of pair addresses.\n\t */\n\tfunction getAllPairs() public view returns (address[] memory) {\n\t\treturn pairs.values();\n\t}\n\n\t/**\n\t * @notice Returns the list of all trade token addreses.\n\t * @return Array of pair addresses.\n\t */\n\tfunction tradeableTokens() public view returns (address[] memory) {\n\t\treturn tradeTokens.values();\n\t}\n\n\t/**\n\t * @return Returns the basePair address.\n\t */\n\tfunction basePairAddr() public view returns (address) {\n\t\treturn pairs.at(0);\n\t}\n\n\t/**\n\t * @return count the total count of listed pairs.\n\t */\n\tfunction pairsCount() public view returns (uint64) {\n\t\treturn uint64(pairs.length());\n\t}\n\n\t/**\n\t * @notice Estimates the amount of output tokens to receive for a given input amount, considering slippage.\n\t * @dev The function calculates the amount of output tokens after applying the dynamic fee and slippage.\n\t * @param inPair The address of the input pair.\n\t * @param outPair The address of the output pair.\n\t * @param inAmount The amount of input tokens.\n\t * @param slippage The maximum allowable slippage percentage (e.g., 50 for 0.5%).\n\t * @return amountOut The estimated amount of output tokens.\n\t */\n\tfunction estimateOutAmount(\n\t\taddress inPair,\n\t\taddress outPair,\n\t\tuint256 inAmount,\n\t\tuint256 slippage\n\t) public view returns (uint256 amountOut) {\n\t\t// Ensure the input and output pairs are registered in the Router\n\t\trequire(pairs.contains(inPair), \"Router: Input pair not found\");\n\t\trequire(pairs.contains(outPair), \"Router: Output pair not found\");\n\n\t\t// Instantiate Pair contracts for input and output pairs\n\t\tPair inputPair = Pair(inPair);\n\t\tPair outputPair = Pair(outPair);\n\n\t\t// Get reserves for input and output pairs from their respective reserve methods\n\t\tuint256 inPairReserve = inputPair.reserve();\n\t\tuint256 outPairReserve = outputPair.reserve();\n\n\t\t// Calculate the fee using the Router's computeFeePercent method\n\t\tuint256 feePercent = computeFeePercent(inPair, inAmount);\n\n\t\t// Adjust input amount for slippage\n\t\tuint256 adjustedInAmount = Slippage.compute(inAmount, slippage);\n\n\t\t// Calculate the output amount using the AMM formula, accounting for the computed fee and slippage\n\t\tamountOut = Amm.getAmountOut(\n\t\t\tadjustedInAmount,\n\t\t\tinPairReserve,\n\t\t\toutPairReserve\n\t\t);\n\n\t\tamountOut -= (amountOut * feePercent) / FeeUtil.MAX_PERCENT;\n\t}\n}\n"
    },
    "contracts/router/User.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.26;\n\nabstract contract UserModule {\n\tstruct User {\n\t\tuint256 id;\n\t\taddress addr;\n\t\tuint256 referrerId;\n\t\tuint256[] referrals;\n\t}\n\n\tuint256 public userCount;\n\tmapping(address => User) public users;\n\tmapping(uint256 => address) public userIdToAddress;\n\n\tevent UserRegistered(\n\t\tuint256 userId,\n\t\taddress userAddress,\n\t\tuint256 referrerId\n\t);\n\tevent ReferralAdded(uint256 referrerId, uint256 referralId);\n\n\t/// @notice Gets the referrer and referrer ID of a user.\n\t/// @param userAddress The address of the user.\n\t/// @return referrerId The ID of the referrer, 0 if none.\n\t/// @return referrerAddress The address of the referrer, address(0) if none.\n\tfunction getReferrer(\n\t\taddress userAddress\n\t) public view returns (uint256 referrerId, address referrerAddress) {\n\t\tUser storage user = users[userAddress];\n\t\treferrerId = user.referrerId;\n\t\treferrerAddress = userIdToAddress[referrerId];\n\t}\n\n\tfunction getUserId(\n\t\taddress userAddress\n\t) external view returns (uint256 userId) {\n\t\treturn users[userAddress].id;\n\t}\n\n\t/// @notice Internal function to create or get the user ID.\n\t/// @param userAddr The address of the user.\n\t/// @param referrerId The ID of the referrer.\n\t/// @return The ID of the user.\n\tfunction _createOrGetUserId(\n\t\taddress userAddr,\n\t\tuint256 referrerId\n\t) internal returns (uint256) {\n\t\tif (users[userAddr].id != 0) {\n\t\t\treturn users[userAddr].id;\n\t\t}\n\n\t\tuserCount++;\n\t\tusers[userAddr] = User({\n\t\t\tid: userCount,\n\t\t\taddr: userAddr,\n\t\t\treferrerId: referrerId,\n\t\t\treferrals: new uint256[](1)\n\t\t});\n\t\tuserIdToAddress[userCount] = userAddr;\n\n\t\tif (referrerId != 0 && userIdToAddress[referrerId] != address(0)) {\n\t\t\tusers[userIdToAddress[referrerId]].referrals.push(userCount);\n\t\t\temit ReferralAdded(referrerId, userCount);\n\t\t}\n\n\t\temit UserRegistered(userCount, userAddr, referrerId);\n\t\treturn userCount;\n\t}\n}\n"
    },
    "contracts/test-case/TestingBasePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport \"../pair/BasePair.sol\";\n\ncontract TestingBasePair is BasePair {\n\tfunction mint(address to, uint256 amt) external {\n\t\tMintableERC20(address(tradeToken)).mint(to, amt);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}